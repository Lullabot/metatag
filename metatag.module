<?php
/**
 * Hook implementations for metatag module.
 */

/**
 * Implements hook_page_attachments().
 *
 * Load all meta tags for this page except the title.
 */
function metatag_page_attachments(array &$attachments) {
  if (!metatag_is_current_route_supported()) {
    return;
  }

  $metatags = metatag_get_tags_from_route();

  if (!empty($metatags)) {
    // Load all tag plugins.
    $tag_manager = \Drupal::service('plugin.manager.metatag.tag');
    $tags = $tag_manager->getDefinitions();
    // Remove the title tag as it is processed at metatag_preprocess_html().
    unset($tags['title']);

    // Loop plugins and render them.
    foreach ($tags as $tag_id => $tag_definition) {
      $tag = $tag_manager->createInstance($tag_id);
      // If the config_entity has a value for this tag, set it.
      if (isset($metatags[$tag_id])) {
        $tag->setValue($metatags[$tag_id]);
        $metatags[$tag_id] = $tag->render();
        $attachments['#attached']['html_head'][] = [$tag->render(), $tag_id];
      }
    }
  }
}

/**
 * Implements hook_preprocess_html().
 *
 * Alter the page title.
 */
function metatag_preprocess_html(array &$variables) {
  if (!metatag_is_current_route_supported()) {
    return;
  }

  $metatags = metatag_get_tags_from_route();
  if (!empty($metatags)) {
    if (isset($metatags['title'])) {
      $variables['head_title'] = array('metatag' => $metatags['title']);
    }
  }
}

/**
 * Load the meta tags by processing the route parameters.
 *
 * @return array()
 *   All of the meta tags identified for the header.
 */
function metatag_get_tags_from_route() {
  // First we load global defaults.
  $metatags = entity_load('metatag_defaults', 'global');
  $token_replacements = array();

  // Check if we should apply entity overrides.
  $entity = metatag_get_route_entity();
  if (!empty($entity)) {
    $entity_type = $entity->getEntityTypeId();
    $entity_metatags = entity_load('metatag_defaults', $entity_type);
    if ($entity_metatags != NULL) {
      // Merge with global defaults.
      $metatags->set('tags', array_merge($metatags->get('tags'), $entity_metatags->get('tags')));
      // Prepare token replacements array.
      $token_replacements = array($entity_type => $entity);
    }

    // Now check if we should apply bundle overrides.
    $entity_bundle = $entity->bundle();
    $bundle_metatags = entity_load('metatag_defaults', $entity_type . '__' . $entity_bundle);
    if ($bundle_metatags != NULL) {
      // Merge with existing defaults.
      $metatags->set('tags', array_merge($metatags->get('tags'), $bundle_metatags->get('tags')));
    }
  }

  // Perform token replacements on metatags and return them.
  $raw_metatags = $metatags->get('tags');
  $processed_metatags = array();
  foreach($raw_metatags as $metatag_id => $metatag_value) {
    $processed_metatags[$metatag_id] = \Drupal::token()->replace($metatag_value, $token_replacements);
  }

  return $processed_metatags;
}

/**
 * Identify whether the current route is supported by the module.
 *
 * @return bool
 *   TRUE if the current route is supported.
 */
function metatag_is_current_route_supported() {
  // Ignore admin paths.
  $route = \Drupal::routeMatch()->getRouteObject();
  $is_admin = \Drupal::service('router.admin_context')->isAdminRoute($route);
  if ($is_admin) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Returns the entity of the current route.
 *
 * @return EntityInterface
 *   The entity or NULL if this is not an entity route.
 */
function metatag_get_route_entity() {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();
  // Look for a canonical entity view page, e.g. node/{nid}, user/{uid}, etc.
  $matches = array();
  preg_match('/entity\.(.*)\.canonical/', $route_name, $matches);
  if (!empty($matches[1])) {
    $entity_type = $matches[1];
    return $route_match->getParameter($entity_type);
  }

  return NULL;
}
